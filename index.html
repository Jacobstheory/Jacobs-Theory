<script>
(async function () {
  // ---- 1) Load content.html into <main id="content">
  const host = document.getElementById('content');
  try {
    const resp = await fetch('content.html', { cache: 'no-store' });
    const html = await resp.text();
    host.innerHTML = html;
  } catch (e) {
    host.innerHTML = `<p style="color:#f88">Could not load content.html</p>`;
    return;
  }

  // ---- 2) Collect H1/H2/H3 headings
  const headings = Array.from(host.querySelectorAll('h1, h2, h3'))
    .filter(h => h.textContent.trim().length);

  // Ensure each heading has an id
  headings.forEach(h => {
    if (!h.id) {
      h.id = h.textContent.trim()
        .toLowerCase()
        .replace(/[^\w]+/g, '-')
        .replace(/(^-|-$)/g, '');
    }
  });

  // ---- 3) Build nested UL for ToC
  const toc = document.getElementById('toc').querySelector('ul');
  toc.innerHTML = ''; // reset

  // Utility to create a link item
  const liFor = (h) => {
    const li = document.createElement('li');
    li.className = 'node';
    const a = document.createElement('a');
    a.href = `#${h.id}`;
    a.textContent = h.textContent.trim();
    li.appendChild(a);
    return li;
  };

  // We’ll keep stacks for H1 > H2 > H3
  let currentH1UL = toc;        // top-level <ul>
  let currentH2UL = null;       // inside a given H1
  let currentH3UL = null;       // inside a given H2

  let lastH1LI = null;
  let lastH2LI = null;

  headings.forEach(h => {
    const level = h.tagName === 'H1' ? 1 : h.tagName === 'H2' ? 2 : 3;

    if (level === 1) {
      const li = liFor(h);
      li.classList.add('toc-parent');
      currentH1UL.appendChild(li);
      lastH1LI = li;

      // fresh level-2 UL under this H1
      currentH2UL = document.createElement('ul');
      li.appendChild(currentH2UL);
      // reset level-3
      currentH3UL = null;
      lastH2LI = null;
    }

    if (level === 2) {
      // must be inside a H1
      if (!currentH2UL) {
        // If there was no H1 before, attach to root
        currentH2UL = toc;
      }
      const li = liFor(h);
      li.classList.add('toc-parent');
      currentH2UL.appendChild(li);
      lastH2LI = li;

      // fresh level-3 UL under this H2
      currentH3UL = document.createElement('ul');
      li.appendChild(currentH3UL);
    }

    if (level === 3) {
      // must be inside a H2
      let ul = currentH3UL;
      if (!ul) {
        // fallback to last H2, else root
        ul = lastH2LI?.querySelector('ul') || toc;
        currentH3UL = ul;
      }
      const li = liFor(h);
      ul.appendChild(li);
    }
  });

  // ---- 4) Toggle open/closed on parent clicks (but not on link clicks)
  const wrap = document.querySelector('aside');
  toc.addEventListener('click', (e) => {
    if (e.target.closest('a')) return; // don’t toggle when clicking a link
    const parent = e.target.closest('.toc-parent');
    if (!parent) return;
    const childUL = parent.querySelector(':scope > ul');
    if (!childUL) return;
    const isHidden = childUL.hidden === true;
    childUL.hidden = !isHidden;
    parent.classList.toggle('collapsed', !isHidden);
  });

  // Start with all children collapsed (keep top level open)
  toc.querySelectorAll(':scope > li > ul').forEach(ul => {
    ul.hidden = true;
    ul.parentElement.classList.add('collapsed');
  });

  // ---- 5) Filter (hides groups that don’t match, but keeps tree structure)
  const filter = document.getElementById('filter');
  filter.addEventListener('input', () => {
    const q = filter.value.trim().toLowerCase();
    // Show all if no query
    if (!q) {
      toc.querySelectorAll('li').forEach(li => li.style.display = '');
      return;
    }

    // test each group + their children
    toc.querySelectorAll('.toc-parent').forEach(group => {
      const label = group.querySelector(':scope > a')?.textContent.toLowerCase() || '';
      const hitsTop = label.includes(q);
      const children = group.querySelectorAll(':scope > ul > li');
      const hitsChild = Array.from(children).some(li =>
        li.querySelector('a')?.textContent.toLowerCase().includes(q)
      );
      group.style.display = (hitsTop || hitsChild) ? '' : 'none';
      // If child matched, open the group so matches are visible
      if (hitsChild) {
        const ul = group.querySelector(':scope > ul');
        if (ul) {
          ul.hidden = false;
          group.classList.remove('collapsed');
        }
      }
    });

    // also test leaf li’s under any level-2 ULs
    toc.querySelectorAll('li:not(.toc-parent)').forEach(li => {
      const txt = li.querySelector('a')?.textContent.toLowerCase() || '';
      li.style.display = txt.includes(q) ? '' : 'none';
    });
  });

  // ---- 6) Expand / Collapse all (only sub-lists, top-level stays visible)
  const expandAllBtn  = document.getElementById('expandAll');
  const collapseAllBtn = document.getElementById('collapseAll');

  expandAllBtn.addEventListener('click', () => {
    toc.querySelectorAll(':scope > li > ul, :scope > li > ul ul').forEach(ul => ul.hidden = false);
    toc.querySelectorAll('.toc-parent').forEach(li => li.classList.remove('collapsed'));
  });

  collapseAllBtn.addEventListener('click', () => {
    // collapse only the immediate children of H1 (and their descendants)
    toc.querySelectorAll(':scope > li > ul').forEach(ul => ul.hidden = true);
    toc.querySelectorAll(':scope > li > ul ul').forEach(ul => ul.hidden = true);
    toc.querySelectorAll('.toc-parent').forEach(li => li.classList.add('collapsed'));
  });

  // ---- 7) Active section highlight on scroll
  const links = Array.from(toc.querySelectorAll('a'));
  const byId = new Map(links.map(a => [a.getAttribute('href').slice(1), a]));
  const obs = new IntersectionObserver((entries) => {
    entries.forEach(({ target, isIntersecting }) => {
      const a = byId.get(target.id);
      if (!a) return;
      const node = a.parentElement;
      if (isIntersecting) {
        node.classList.add('active');
      } else {
        node.classList.remove('active');
      }
    });
  }, { rootMargin: '0px 0px -60% 0px', threshold: [0, 1] });

  headings.forEach(h => obs.observe(h));

})();
</script>
